# 인덱스 기본 사용법
## 2.2.1 인덱스를 사용한다는 것
- 인덱스를 정상적으로 사용한다는 것
  - '인덱스를 정상적으로 사용한다'는 표현은 인덱스의 이점을 최대한 활용하는 것을 의미
  - 인덱스를 통해 필요한 데이터에 빠르게 접근하고, 불필요한 데이터를 읽지 않도록 하는 것
### Index Range Scan
- 인덱스를 통해 필요한 데이터의 시작점을 찾고, 그 지점부터 필요한 부분만 읽는 방법
- 예를 들어, 사전에서 'apple'부터 'banana'까지의 단어를 찾는다면 'apple'이 시작점이 되고 'banana'까지 필요한 부분만 읽음
- 이렇게 하면 시간과 자원을 절약할 수 있음

### Index Full Scan
- Index Full Scan은 인덱스를 전체 다 읽는 방법
- 이는 마치 사전의 모든 단어를 처음부터 끝까지 다 읽는 것과 같음
- 필요한 부분만 읽는 것이 아니라 모든 데이터를 다 읽으므로 시간이 더 많이 걸리고 비효율적

### 인덱스 컬럼을 가공한다는 것
- 인덱스 컬럼을 가공한다는 것은 인덱스 컬럼에 어떤 변형을 가하는 것
- 예를 들어, 소문자를 대문자로 변환하거나, 특정 패턴을 찾기 위해 문자열을 조작하는 경우

### 인덱스 컬럼을 가공하면 생기는 문제
- 인덱스 컬럼을 가공하면 인덱스가 가공된 상태의 값을 기준으로 정렬되어 있지 않기 때문에, 원하는 데이터를 빠르게 찾기 어려움
- 예를 들어, 데이터베이스에 'apple', 'banana', 'cherry'가 저장되어 있고, 이를 대문자로 변환해서 찾는다면 인덱스는 'APPLE', 'BANANA', 'CHERRY'로 정렬되지 않으므로 시작점을 찾기 어려움
- 그래서 Index Range Scan이 불가능해지고, Index Full Scan처럼 모든 데이터를 읽어야 하는 상황 발생

### 결론
- 인덱스를 정상적으로 사용하려면 인덱스 컬럼을 가공하지 않고 원래 상태 그대로 사용하는 것이 좋음
- 필요한 부분만 빠르게 읽을 수 있어 효율적임
- 인덱스 컬럼을 가공하면 전체 데이터를 다 읽어야 하므로 비효율적이다

## 2.2.2 인덱스를 Range Scan할 수 없는 이유
- 인덱스 스캔 시작점을 찾을 수 없기 때문
- 즉, 끝까지 탐색해야 한다. Index Full Scan 발생
- 예시
```sql
where substr(생년월일, 5, 2) = '05';
```
- 생년월일 문자열의 5번째와 6번째 문자를 추출하여 '05'와 비교 -> 인덱스 시작지점을 찾을 수 없음
```sql
where nvl(주문수량, 0) < 100;
```
- 값이 null이면 0으로 치환한 값 기준으로 100보다 작은 레코드를 찾아달라고 쿼리를 작성하면 인덱스 스캔 시작지점을 찾을 수 없음
```sql
where 업체명 like '%대한%';
```
- 대한으로 시작하는 값은 특정 구간에 모여 있으므로 Range Scan이 가능하지만 '대한'을 포함하는 값은 전체 구간에 걸쳐 흩어져 있어 Range Scan이 불가능
```sql
where (전화번호 = :tel_no OR 고객명 = :cust_nm);
```
- or조건으로 검색할 때, 수직적 탐색을 통해 전화번호가 '01033434322'이거나 고객명이 '홍길동'인 어느 한 시작지점을 바로 찾을 수 없음 -> Range Scan 불가능

#### Or Expansion
- 다음과 같은 예시에서 고객명, 전화번호 인덱스 각각에 대해 Index Range Scan이 가능
```sql
select *
from 고객
where 고객명 = :cust_nm -- 고객명이 선두 컬럼인 인덱스 Range Scan
union all
select *
from 고객
where 전화번호 = :tel_no -- 전화번호가 선두 컬럼인 인덱스 Range Scan
and (고객명 <> :cust_nm or 고객명 is null)
```
- OR 조건식을 SQL 옵티마이저가 위와 같은 형태로 변환할 수 있는데, 이를 SQL Expansion이라고 함
- use_concat 힌트를 이용해 OR Expansion을 유도했을 때의 실행 계획
```sql
select /*+ use_concat */ * from 고객
where (전화번호 = :tel_no OR 고객명 = :cust_nm)
```
```text
Execution Plan
----------------------------------------------------------
| Id  | Operation                      | Name   | Rows  |
----------------------------------------------------------
|   0 | SELECT STATEMENT               |        |     2 |
|   1 |  UNION-ALL                     |        |       |
|   2 |   TABLE ACCESS BY INDEX ROWID  | 고객   |     1 |
|*  3 |    INDEX RANGE SCAN            | IDX_1  |     1 |
|   4 |   TABLE ACCESS BY INDEX ROWID  | 고객   |     1 |
|*  5 |    INDEX RANGE SCAN            | IDX_2  |     1 |
----------------------------------------------------------
```

- IN 조건절
```sql
where 전화번호 in ( :tel_no1, :tel_no2);
```
- 수직적 탐색을 통해 전화번호가 '01012345567'이거나 '01034345838'인 어느 한 지점을 바로 찾을 수 있을까
  - 불가능
  - IN 조건은 OR 조건을 표현하는 다른 방식
  - UNION ALL 방식으로 작성하면, 각 브랜치 별로 인덱스 스캔 시작점을 찾을 수 있음
```sql
select *
from 고객
where 전화번호 = :tel_no1
union all
select *
from 고객
where 전화번호 = :tel_no2
```
- 그래서!
  - IN조건절에 대해서는 SQL 옵티마이저가 IN-List Iterator 방식을 사용
  - IN-List 개수만큼 Index Range Scan을 반복하는 것
  - 이를 통해 SQL을 UNION ALL 방식으로 변환한 것과 같은 효과를 얻을 수 있음
```text
Execution Plan
----------------------------------------------------------
| Id  | Operation                      | Name         | Rows  |
----------------------------------------------------------
|   0 | SELECT STATEMENT               |              |     2 |
|   1 |  UNION-ALL                     |              |       |
|   2 |   TABLE ACCESS BY INDEX ROWID  | 고객         |     1 |
|*  3 |    INDEX RANGE SCAN            | IDX_전화번호 |     1 |
|   4 |   TABLE ACCESS BY INDEX ROWID  | 고객         |     1 |
|*  5 |    INDEX RANGE SCAN            | IDX_전화번호 |     1 |
----------------------------------------------------------

```

#### 정리
- 인덱스를 정상적으로 사용한다
  - 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미
- OR 또는 IN 조건절은 옵티마이저의 쿼리변환 기능을 통해 Index Range Scan으로 처리되기도 함

## 2.2.3 더 중요한 인덱스 사용 조건
- 인덱스를 Range Scan 하기 위한 가장 첫 번째 조건은 인덱스 선두 컬럼이 조건절에 있어야 한다는 사실
- 아래 SQL은 인덱스 컬럼을 가공했는데, 인덱스를 Range Scan한다
```sql
select * from TXA1234
where 기준연도 = :stdr_year
and substr(과세구분코드, 1, 4) = :txtn_dcd
and 보고회사 = :rpt_tmrd
and 실명확인번호 = :rnm_cnfm_no;
```
```text
Execution Plan
----------------------------------------------------------
| Id  | Operation                      | Name          | Rows  |
----------------------------------------------------------
|   0 | SELECT STATEMENT               |               |     1 |
|   1 |  TABLE ACCESS BY INDEX ROWID   | TXA1234       |     1 |
|*  2 |   INDEX RANGE SCAN             | IDX_TXA1234   |     1 |
----------------------------------------------------------
```
- 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range Scan은 무조건 가능
- 문제는, 인덱스를 Range Scan 한다고 해서 항상 성능이 좋은 건 아니라는 사실

### 인덱스 잘 타니깐 튜닝 끝?
- SQL을 개발하면서 실행계획을 확인하지 않는 개발자가 대다수
- 확인하더라도 인덱스를 타는지, 안 타는지 확인하는 수준에 그침
- 인덱스를 잘 타면 성능도 문제없다고 생각함
```sql
Execution Plan
----------------------------------------------------------
| Id  | Operation                                  | Name         | Rows  |
----------------------------------------------------------
|   0 | SELECT STATEMENT Optimizer=ALL_ROWS        |              |     1 |
|   1 |  TABLE ACCESS BY INDEX ROWID               | 주문상품      |     1 |
|*  2 |   INDEX RANGE SCAN                         | 주문상품_N1   |     1 |
----------------------------------------------------------
```
- 그렇다면 위 실행계획은 인덱스를 잘 타니까 성능에 문제가 없을까?
  - 주문상품_N1 인덱스는 [주문일자 + 상품번호] 순으로 구성
  - 이 테이블에 쌓이는 데이터량은 하루 평균 100만건
- 아래 조건절은 인덱스 선두 컬럼인 주문일자가 조건절에 있고, 가공하지 않은 상태이므로 인덱스를 Range Scan하는 데 문제가 없음
- 스캔 시작점을 찾아 스캔하다가 중간에 멈출 수 있음
- BUT, 
  - 인덱스를 정말 잘 타는지는 인덱스 리프 블록에서 스캔하는 양을 따져봐야 알 수 있음

```sql
SELECT *
FROM 주문상품
WHERE 주문일자 = :ord_dt
AND 상품번호 LIKE '%PING%';

SELECT *
FROM 주문상품
WHERE 주문일자 = :ord_dt
  AND SUBSTR(상품번호, 1, 4) = 'PING';
```
- 위 SQL에서 상품번호는 스캔 범위를 줄이는 데 전혀 역할을 하지 못함
- 첫 번째 SQL은 중간 값 검색
- 두 번째 SQL은 컬럼을 가공했기 때문
- 따라서 위 조건절을 처리할 때 인덱스에서 스캔하는 데이터량은 주문일자 조건을 만족하는 100만건
- 이를 두고 인덱스를 잘 탄다고 말할 수 있을까? X

## 2.2.4 인덱스를 이용한 소트 연산 생략
