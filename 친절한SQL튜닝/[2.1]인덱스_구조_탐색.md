# 인덱스 구조 및 탐색
## 2.1.1 미리보는 인덱스 튜닝
### 데이터를 찾는 두 가지 방법
1. 테이블 전체를 스캔한다.
2. 인덱스를 이용한다.

### 인덱스 튜닝의 두 가지 핵심요소
- 인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용
- 온라인 트랜잭션 처리(Online Transaction Processing, OLTP) 시스템에서는 소량 데이터를 주로 검색하므로 인덱스 튜닝이 중요함
1. "인덱스 스캔 효율화 튜닝"
   - 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것
   - 일정한 기준으로 정렬되어 있다면, 소량만 스캔할 수 있음
   - 정렬되어 있지 않았다면, 시작과 끝까지 스캔해야하는 최악의 상황 발생
2. "랜덤 액세스 최소화 튜닝"
   - 인덱스 스캔 후 테이블 레코드를 액세스할 때 랜덤 I/O 방식을 사용
   - 랜덤 I/O방식도 튜닝할 수 있다는 뜻
- **SQL 튜닝은 랜덤 I/O와의 전쟁**

### SQL 튜닝은 랜덤 I/O와의 전쟁
- 데이터베이스 성능이 느린 이유 -> 디스크 I/O
  - 읽어야 할 데이터량이 많고, 그 과정에서 디스크 I/O가 많이 발생할 때
  - 인덱스를 많이 사용하는 OLTP 시스템이라면 디스크 I/O 중에서도 랜덤 I/O가 중요
- 성능을 위해 DBMS가 제공하는 많은 기능이 느린 랜덤 I/O를 극복하기 위해 개발됨
  - IOT
  - 클러스터
  - 파티션
  - 테이블 Prefetch
  - Batch I/O
  - 등등...

## 2.1.2 인덱스 구조
### 인덱스
- 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트
- 책 뒤쪽에 있는 색인과 같은 역할
- DBMS는 일반적으로 B*Tree 인덱스를 사용

- 루트와 브랜치 블록에는 키값을 갖지 않는 특별한 레코드가 하나 있음
- 가장 왼쪽 첫번째 레코드를 "LMC"라고 하며 "Leftmost Child"의 줄임말
- LMC
  - 자식 노드 중 가장 왼쪽 끝에 위치한 블록
  - LMC가 가리키는 주소로 찾아간 블록에는 키값을 가진 첫 번째 레코드보다 작거나 같은 레코드가 저장
  - 리프 블록에 저장된 각 레코드는 키값 순으로 정렬돼 있을 뿐만 아니라 테이블 레코드를 가리키는 주소값 = ROWID
  - 인덱스 키 값이 같으면 ROWID 순으로 정렬
  - ROWID는 아래와 같이 데이터 블록 주소와 로우 번호로 구성되므로 이 값을 알면 테이블 레코드를 찾아갈 수 있음
```text
- ROWID = 데이터 블록 주소 + 로우 번호
- 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
- 블록 번호 : 데이터파일 내에서 부여한 상대적 순번
- 로우 번호 : 블록 내 순번
```
- 인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있음
```text
- 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
- 수평적 탐색 : 데이터를 찾는 과정
```

## 2.1.3 인덱스 수직적 탐색
- 정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정
- 인덱스 스캔 시작지점을 찾는 과정
- 인덱스를 수직적으로 탐색할 때, 루트를 포함한 브랜치 블록은 등산 푯말과 같은 역할을 함
- '조건을 만족하는 첫 번째 레코드'가 목표 지점

## 2.1.4 인덱스 수평적 탐색
- 수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는 데이터가 더 안 나타날 때까지 인덱스 리프 블록을 수평적으로 스캔
- 데이터를 찾는 과정
- 인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖음
- 양방향 연결 리스트(double linked list) 구조
- 인덱스를 수평적으로 탐색하는 이유
    1. 조건절을 만족하는 데이터를 모두 찾기 위해서
  2. ROWID를 얻기 위해서
- 필요한 컬럼을 인덱스가 모두 갖고 있어 인덱스만 스캔하고 끝나는 경우도 있지만, 일반적으로 인덱스를 스캔하고서 테이블도 액세스한다. 이 때 ROWID가 필요

## 2.1.5 결합 인덱스 구조와 탐색
- 두 개 이상 컬럼을 결합해서 인덱스를 만들 수 있음
- 틀린 예시
```sql
create index 고객_N1 on 고객(고객명, 성별);
```
1. 고객명 and 성별
```sql
select * from 고객 where 고객명 = '이재희' and 성별 = '남';
```
2. 성별 and 고객명
```sql
select * from 고객 where 성별 = '남' and 고객명 = '이재희';
```
- 1번의 경우 총 고객 50명에서 '이재희'인 행을 25건 찾고, 거기서 고객명을 검사해 최종적으로 2명 출력
  - 25번의 검사
- 2번의 경우 총 고객 50명에서 '남'인 행을 2건 찾고. 거기서 고객명을 검사해 최종적으로 2명 출력
  - 2번의 검사
- 선택도가 낮은 성별 컬럼을 앞쪽에 두고 결합인덱스를 생성해야 검사 횟수를 줄일 수 있어 성능에 유리하다 -> X 틀린 것
- 틀린 이유
  - B*Tree 인덱스는 엑셀 필터링처럼 평면 구조가 아님
  - 루트에서 브랜치를 거쳐 리프 블록까지 탐색하면서 '남'이면서 '이재희'인 고객을 바로 찾아감
  - 거기서부터 두 건을 스캔
  - 인덱스 구성에 따라 성능에 차이가 나는 것은 맞지만 위의 예시처럼 설명하는 것은 틀린 것

### Balanced의 의미
- delete 작업 때문에 인덱스가 불균형 상태에 놓일 수 있다고 설명한 자료들이 있을 수 있음
- B*Tree 구조는 항상 균형을 이룬다
- 자료구조에서 B*Tree 구조 동작원리를 살펴보면 알 수 있다
- 삭제하든, 추가되든 B*Tree 구조는 균형을 유지한다.
