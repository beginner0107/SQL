# SQL 파싱과 최적화

## 1.1.1 구조적, 집합적, 선언적 질의 언어

- SQL은 "Structured Query Language"의 줄임말
- 구조적 질의 언어
- 원하는 결과집합을 ```구조적, 집합적```으로 선언하지만, 그 결과집합을 만드는 과정은 ```절차적```
- ```프로시저```가 필요
  - 그런 프로시저를 만들어 내는 DBMS 내부 엔진이 ```SQL 옵티마이저```
    1. 사용자가 SQL을 작성한다.
    2. 옵티마이저가 DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만든다.
       - 이 과정을 ```SQL최적화```라고 한다.


### 예시
- 다음은 SQL을 사용하여 데이터베이스에서 고객의 주문을 조회하는 간단한 쿼리
```mysql
SELECT CustomerName, OrderDate, TotalAmount
FROM Orders
WHERE CustomerID = 12345;
```
- 이 쿼리는 "Orders" 테이블에서 "CustomerID"가 12345인 고객의 주문에 대한 정보를 가져옵니다. 
- 그러나 데이터베이스에서 이 쿼리를 실행하는 방법은 ```여러 가지```일 수 있습니다.
    1. 인덱스를 사용하였을 때 더 효율적인 경우
    2. 인덱스를 사용하지 않고 풀 스캔으로 검색했을 때 빠른 경우
- 일부 데이터베이스 시스템은 데이터를 가져오는 데 사용할 최적의 실행 계획을 결정하기 위해 통계 및 기타 정보를 고려할 수 있다.

### 요약
- 최적화 과정은 SQL 옵티마이저에 의해 수행된다.
- 옵티마이저는 쿼리를 분석하고 데이터베이스 구조를 고려하여 최적의 실행 계획을 결정
- 최적화된 실행 계획에 따라 데이터베이스 엔진이 작업을 수행하여 원하는 결과를 제공

## 1.1.2 SQL 최적화
- SQL을 실행하기 전 최적화 과정
  1. SQL 파싱
    - 사용자로부터 SQL을 전달받으면, SQL 파서(Parser)가 파싱을 진행
     - 파싱 트리 생성
       - SQL 문을 이루는 개별 구성요소를 분석해서 파싱 트리 생성
       - Syntax 체크 : 문법적 오류가 없는지 확인
       - Semantic 체크 : 의미상 오류가 없는지 확인
         - 예시1) 존재하지 않는 테이블 또는 컬럼을 사용했는지
         - 예시2) 사용한 오브젝트에 대한 권한이 있는지 확인
           - 뜻 : 데이터베이스 시스템이 SQL문을 실행하기 위해 필요한 데이터베이스 객체(테이블, 뷰, 프로시저)에 대한 권한을 확인하는 과정
           - 예시2에 대한 예시 : 사용자가 특정 테이블을 조회하는 SQL을 실행하려고 할 때, 데이터베이스 시스템은 해당 사용자에게 그 테이블에 대한 SELECT 권한이 있는지 확인
  2. SQL 최적화
     - 옵티마이저(Optimizer)의 역할
     - SQL 옵티마이저가 하는 일?
       - 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성해서 비교한 후 가장 효율적인 하나늘 선택
       - 데이터베이스 성능을 결정하는 가장 핵심적인 엔진
  3. 로우 소스 생성
     - SQL 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅하는 단계
     - 로우 소스 생성기 (Row-Source Generator)가 그 역할을 맡음

### 예시
- 특정 회사의 직원에 대한 데이터를 가지고 있다고 가정
- 데이터베이스에는 'employees' 테이블이 있으며, 각 직원의 이름과 부서ID 등의 정보가 포함되어 있음
```mysql
SELECT first_name, last_name, department_id
FROM employees
WHERE department_id = 10;
```
1. SQL 파싱 트리 생성
```text
SELECT
  |
  |--COLUMNS
  |    |
  |    |--first_name
  |    |--last_name
  |
  |--FROM
  |    |
  |    |--employees
  |
  |--WHERE
       |
       |--department_id = 10

```
2. SQL 최적화
- SQL 옵티마이저가 다양한 실행 경로를 고려하여 최적의 실행 계획을 선택
- 이 경우, 'department_id'에 인덱스가 있을 경우 인덱스 스캔을 사용하는 것이 가장 효율적

3. 로우 소스 생성
- SQL 옵티마이저가 선택한 실행 계획을 실제 실행 가능한 코드 또는 프로시저 형태로 변환
```mysql
-- 프로시저 생성
CREATE PROCEDURE GetEmployeesByDepartment
AS
BEGIN
    -- employees 테이블에서 department_id가 10인 직원들을 선택하여 결과 반환
    SELECT first_name, last_name, department_id
    FROM employees
    WHERE department_id = 10;
END;
```

## 1.1.3 SQL 옵티마이저
- 사용자가 원하는 작업을 가장 효율적으로 수행할 수 있는 최적의 데이터 엑세스 경로를 선택해 주는 DBMS의 핵심 엔진
1. 사용자로부터 전달받은 쿼리를 수행하는 데 후보군이 될만한 실행계획들을 찾아낸다.
2. 데이터 딕셔너리(Data Dictionary)에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용을 산정
3. 최저 비용을 나타내는 실행계획을 선택

### 예시
- 고객 테이블에서 특정 지역에 거주하는 고객들의 주문 정보를 모두 조회하는 쿼리:
```sql
SELECT *
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE c.region = '서울특별시';
```
1. 후보 실행 계획 찾기:

- 풀 테이블 스캔: customers 테이블의 모든 레코드를 스캔하고 region 열을 확인하여 조건에 맞는 레코드를 찾습니다.
- 인덱스 스캔: customers 테이블의 region 열에 대한 인덱스를 사용하여 조건에 맞는 레코드를 빠르게 찾습니다.
- 네스티드 루프 조인: 먼저 customers 테이블에서 조건에 맞는 레코드를 모두 찾고, 각 레코드마다 orders 테이블을 스캔하여 해당 고객의 주문 정보를 찾습니다.
- 해시 조인: customers 테이블과 orders 테이블의 해시 키를 사용하여 조인합니다.

2. 예상 비용 산정:
- 각 후보 실행 계획에 대해 데이터 딕셔너리에 저장된 통계 정보를 사용하여 예상 I/O 비용, CPU 비용 등을 산정합니다.
- 예를 들어, customers 테이블에 100만 개의 레코드가 있고 region 인덱스가 있다고 가정하면, 풀 테이블 스캔은 약 100만 I/O 연산이 필요하고, 인덱스 스캔은 약 1만 I/O 연산이 필요할 것으로 예상됩니다.

3. 최적 실행 계획 선택:
- 예상 비용이 가장 낮은 실행 계획을 선택합니다.
- 이 예시에서는 인덱스 스캔이 가장 효율적이므로 선택될 가능성이 높습니다.



<details>
<summary>추가정보</summary>

### 추가 정보
- SQL 옵티마이저를 DBWR, LGWR, PMON, SMON 같은 백그라운드 프로세스로 이해하기 쉽다.
- 서버 프로세스가 SQL을 전달하면, 옵티마이저가 최적화해서 실행계획을 돌려준다고 생각하는 것이다.
- 하지만, 옵티마이저는 별도의 프로세스가 아니라 서버 프로세스가 가진 기능(Function)일 뿐이다.
- SQL 파서와 로우 소스 생성기도 마찬가지다.

#### 추가 정보 설명
- 옵티마이저는 별도의 백그라운드 프로세스가 아니라 데이터베이스 시스템 내부의 일부 기능이다
- 서버 프로세스가 SQL 쿼리를 받으면 옵티마이저가 그 쿼리를 분석하여 가장 효율적인 실행 계획을 결정하고, 이를 서버 프로세스에게 반환한다.
- 따라서 옵티마이저는 서버 프로세스가 가진 기능(Function)으로서 동작하며, 쿼리의 최적화를 담당한다.

#### 서버 프로세스
- 서버 프로세스는 데이터베이스 관리 시스템(DBMS)에서 클라이언트와 상호 작용하여 요청을 처리하는 프로세스입니다. 일반적으로 클라이언트로부터의 요청을 받아들이고, 해당 요청을 처리하기 위해 데이터베이스에 접근하거나 쿼리를 실행하는 등의 작업을 수행합니다.
- 예를 들어, 클라이언트가 SQL 쿼리를 보내면, 해당 쿼리를 수행하고 그 결과를 클라이언트에게 반환하는 역할을 수행합니다. 이러한 프로세스들은 사용자와의 상호작용을 담당하며, 데이터베이스 시스템의 외부와의 통신을 담당합니다.

#### 백그라운드 프로세스
- 백그라운드 프로세스(Background Process)는 데이터베이스 관리 시스템(DBMS) 내에서 사용되는 특수한 종류의 프로세스입니다. 이러한 프로세스들은 주로 데이터베이스 시스템의 안정성과 성능을 유지하고 관리하는 역할을 수행합니다. 주로 시스템 또는 보조 작업에 사용됩니다.
- 백그라운드 프로세스들은 사용자가 직접적으로 요청하지 않고도 주기적으로 실행되거나 데이터베이스 시스템이 특정 이벤트를 감지할 때 자동으로 실행됩니다. 이러한 프로세스들은 데이터베이스 시스템의 여러 측면을 관리하며, 주요 백그라운드 프로세스들로는 다음과 같은 것들이 있습니다:
1. DBWR(Database Writer): 데이터베이스 캐시의 변경된 내용을 디스크에 쓰는 역할을 수행합니다.
2. LGWR(Log Writer): 트랜잭션 로그를 디스크에 기록하여 데이터베이스의 일관성과 회복성을 보장합니다.
3. PMON(Process Monitor): 비정상적으로 종료된 사용자 세션을 감지하고, 해당 세션 및 관련 리소스를 정리합니다.
4. SMON(System Monitor): 데이터베이스의 정합성을 유지하고 데이터베이스 관리 작업을 수행합니다. 예를 들어, 불완전한 트랜잭션을 롤백하거나 오브젝트의 정리를 수행합니다.

</details>

## 1.1.4 실행계획과 비용
- SQL 옵티마이저 == 자동차 네비게이션
- DBMS 'SQL 실행경로 미리보기'
  - 실행계획(Execution Plan)
  - SQL 옵티마이저가 생성한 처리절차를 트리 구조로 표현한 것
```text
Execution Plan
-------------------------------------------------------
0    SELECT STATEMENT Optimizer=ALL_ROWS (Cost=209 Card=5, Bytes=175)
1 0    TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (Cost=2 Card=5 Bytes=85)
2 1       NESTED LOOPS (Cost=209 Card=5 Bytes=175)
3 2          TABLE ACCESS (BY INDEX ROWID) OF 'DEPT (Cost=207 Card=1 Bytes=18)
4 3             INDEX (RANGE SCAN) OF 'DEPT_LOC_IDX' (NON_UNIQUE) (Cost=7 Card=1)
5 2          INDEX (RANGE SCAN) OF 'EMP_DEPTNO_IDX'  (NON_UNIQUE) (Cost=1 Card=5)
```
- 미리보기 기능을 통해 자신이 작성하는 SQL이 테이블을 스캔하는지, 인덱스를 스캔하는지 확인 후 실행 계획 변경 가능
```oracle
create table t as
select d.no, e.*
from HR.emp e
   , (select rownum no from dual connect by level <= 1000) d;

CREATE INDEX t_x01 ON t(deptno, NO);
CREATE INDEX t_x02 ON t(deptno, job, NO);

BEGIN
    dbms_stats.gather_table_stats(USER, 't');
END;

SELECT * FROM T
WHERE deptno = 10
  AND NO = 1;
```

### T_X01 인덱스를 타는 경우

| Operation                      | Object                        | Optimizer  | Cost | Cardinality | Bytes |
|--------------------------------|-------------------------------|------------|------|-------------|-------|
| SELECT STATEMENT               |                               | ALL_ROWS   | 2    | 5           | 90    |
| TABLE ACCESS (BY INDEX ROWID) | T                             | ANALYZED   | 2    | 5           | 90    |
| INDEX (RANGE SCAN)            | T_X01                         | ANALYZED   | 1    | 5           | 0     |

- 옵티마이저가 T_X01 인덱스를 선택
- T_X02 인덱스를 선택할 수 있음에서 T_X01을 선택한 이유?
  - Cost를 집중해서 보자

### T_X02 인덱스를 타는 경우

```oracle
SELECT /*+ index(t t_x02) */* FROM T 
WHERE deptno = 10
AND NO = 1;

```

| Operation                      | Object                       | Optimizer | Cost | Cardinality | Bytes |
|--------------------------------|------------------------------|-----------|------|-------------|-------|
| SELECT STATEMENT               |                              | ALL_ROWS  | 7    | 5           | 90    |
| TABLE ACCESS (BY INDEX ROWID) | T                            | ANALYZED  | 7    | 5           | 90    |
| INDEX (SKIP SCAN)             | T_X02                        | ANALYZED  | 6    | 5           | 0     |

- cost(비용)이 큰 것을 확인할 수 있다

### Full Scan 의 경우

```oracle
SELECT /*+ full(t) */* FROM T 
WHERE deptno = 10
AND NO = 1;

```

| Operation         | Object | Optimizer | Cost | Cardinality | Bytes |
|-------------------|--------|-----------|------|-------------|-------|
| SELECT STATEMENT  |        | ALL_ROWS  | 14   | 5           | 90    |
| TABLE ACCESS (FULL) | T      | ANALYZED  | 14   | 5           | 90    |

- Cost(비용) 에 따라 실행 계획을 결정하는 것을 볼 수 있음
  - 비용은 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O 횟수 또는 예상 소요시간을 표현한 값

### 네비게이션과의 예시
- 실행계획에서의 Cost는 어디까지나 예상치
- 목적지에 도착할 때는 외부 요인이 존재하기 때문에 정확히 예측하기 힘듦
- ex) 퇴근 시간, 출근 시간
- 비용은 실제 발생하는 I/O 또는 시간과 많은 차이가 난다
