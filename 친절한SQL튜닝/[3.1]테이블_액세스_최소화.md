# 테이블 엑세스 최소화
- 테이블 랜덤 액세스를 최소화하는 구체적인 방법

## 3.1.1 테이블 랜덤 액세스
### 인덱스 ROWID는 물리적 주소? 논리적 주소?
- 아래는 인덱스를 이용해 테이블을 액세스하는 SQL 실행계획
- SQL이 참조하는 컬럼을 인덱스가 모두 포함하는 경우가 아니면, 인덱스를 스캔한 후 반드시 테이블을 액세스함
```sql
select * from 고객 where 지역 = '서울';

Execution Plan
-----------------------------------------------------------------
0   SELECT STATEMENT Optimizer=ALL_ROWS
1 0    TABLE ACCESS BY INDEX ROWID OF '고객' (TABLE)
2 1       INDEX RANGE SCAN OF '고객_지역_IDX' (INDEX)
```
- 인덱스를 스캔하는 이유는?
  - 소량의 데이터를 인덱스에서 빨리 찾고 테이블 레코드를 찾아가기 위한 주소값
  - ROWID를 얻으려는데 있음
- ROWID란?
  - 물리적 주소라고 생각한다면?
    - 데이터파일 번호, 오브젝트 번호, 블록 번호 같은 물리적 요소
  - 논리적 주소라고 생각한다면?
    - 테이블 레코드를 찾아가기 위한 논리적 주소 정보를 담고 있어 논리적 주소라고 할 수 있음
  - 색인에 기록된 페이지 번호가 ROWID에 해당
  - 프로그래밍의 포인터와는 다른 개념
  - 정리
    - ROWID는 논리적 주소
    - 디스크 상에서 테이블 레코드를 찾아가기 위한 위치 정보를 담음
    - 테이블 레코드와 물리적으로 직접 연결된 구조는 아님
- ROWID의 구성 요소
  - 데이터파일 번호 (Datafile Number): 해당 레코드가 저장된 데이터 파일을 나타냅니다
  - 오브젝트 번호 (Object Number): 데이터베이스 객체(테이블, 인덱스 등)를 식별합니다
  - 블록 번호 (Block Number): 데이터 파일 내의 특정 블록을 식별합니다
  - 행 번호 (Row Number): 블록 내의 특정 행(레코드)을 식별합니다
  - 예시
    - 예를 들어, ROWID가 AAABBB:00001:0001 형태로 주어진다면:
      - 데이터파일 번호 (AAABBB): 특정 데이터 파일을 가리킵니다
      - 블록 번호 (00001): 데이터 파일 내의 특정 블록을 가리킵니다
      - 행 번호 (0001): 블록 내의 특정 행을 가리킵니다
  - 실행 과정
    - 인덱스 스캔: 쿼리가 실행되면, 데이터베이스는 먼저 인덱스를 스캔하여 조건에 맞는 ROWID를 찾습니다
    - ROWID 추출: 인덱스에서 추출된 ROWID는 데이터 파일 번호, 블록 번호, 행 번호 정보를 포함합니다
    - 데이터 파일 접근: 데이터 파일 번호를 사용하여 해당 데이터 파일에 접근합니다
    - 블록 접근: 데이터 파일 내에서 블록 번호를 사용하여 특정 블록에 접근합니다
    - 행 접근: 블록 내에서 행 번호를 사용하여 특정 행(레코드)에 접근합니다
  - 결론
    - ROWID는 논리적 주소로서 데이터베이스 내부에서 레코드의 위치를 빠르게 찾기 위한 정보를 제공
    - 그 내부에 물리적 주소 정보도 포함되어 있어 실제 레코드 접근이 가능
    - 데이터베이스가 인덱스와 테이블을 효율적으로 관리하고 접근할 수 있는 중요한 메커니즘

### 인덱스 ROWID는 우편주소
- ROWID : 우편주소
- 메인메모리 DB가 사용하는 포인터 : 전화번호
- 전화통신은 물리적으로 연결된 통신망을 이용
  - 전화번호를 누르면 곧바로 상대방과 통화 가능
- 우편통신은 봉투에 적힌 대로 우체부 아저씨가 일일이 찾아다니는 구조
  - 전화와는 비교할 수 없이 느림
- 인덱스를 스캔하는 것은 복잡한 처리과정을 거친다는 뜻


## 3.1.2 인덱스 클러스터링 팩터
- Clustering Factor, CF
- '군집성 계수'
- 특정 컬럼을 기준으로 같은 값을 갖는 데이터가 서로 모여있는 정도를 의미
- CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 매우 좋음
- 비유
  - 분가한 열 명의 자녀가 모두 한 동네에 모여 사는 경우
  - 부모가 자녀들 집을 모두 방문하는데 하루면 충분
  - 반면, 여러 지방에 흩어져 산다면 오래 걸림(하루 이상)

### 인덱스 클러스터링 팩터 효과
- CF가 좋은 컬럼에 생성한 인덱스는 검색 효율이 좋다고 함
- 테이블 액세스량에 비해 블록 I/O가 적게 발생함을 의미
- 인덱스 ROWID로 테이블을 액세스할 때, 
  - 오라클이 실행하는 것
    1. 래치 획득과 해시 체인 스캔 과정
    2. 테이블 블록 접근
    3. 블록에 대한 포인터(메모리 주소값)를 해제하지 않음, 유지
        - 이를 버퍼 Pinning이라고 함
    4. 이 상태에서 다음 인덱스 레코드 읽음
        - 마침 '직전과 같은' 테이블 블록을 가리킴
        - 래치 획득과 해시 스캔 과정을 생략하고 테이블 블록을 읽을 수 있음
        - 논리적인 블록 I/O 과정을 생략할 수 있음

## 3.1.3 인덱스 손익분기점
- 인덱스 ROWID를 이용한 테이블 액세스는 생각보다 고비용 구조
- 읽어야 할 데이터가 일정량을 넘는다면?
  - 테이블 전체를 스캔하는 것보다 느려짐
  - Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점을 '인덱스 손익분기점'이라고 부름
- Table Full Scan은 성능이 일정
- 아래 예시처럼 1,000만 건 중 한 건을 조회하든, 10만건을 조회하든, 1,000건을 조회하든 차이가 없음
```sql
select /*+ full(t) */ count(*) big_table t where no <= 1;
select /*+ full(t) */ count(*) big_table t where no <= 10;
select /*+ full(t) */ count(*) big_table t where no <= 100;
select /*+ full(t) */ count(*) big_table t where no <= 1000;
select /*+ full(t) */ count(*) big_table t where no <= 10000;
select /*+ full(t) */ count(*) big_table t where no <= 100000;

select /*+ full(t) */ count(*) big_table t;
```

#### 인덱스를 이용한 테이블 액세스가 Table Full Scan보다 더 느려지게 만드는 핵심적인 두 가지 요인
1. Table Full Scan은 시퀀셜 액세스인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 랜덤 액세스 방식
2. Table Full Scan은 Multiblock I/O인 반면, 인덱스 ROWID를 이용한 테이블 액세스는 Single Block I/O 방식

- 인덱스 CF가 나쁘면 같은 테이블 블록을 여러번 반복 액세스하면서 
  - 논리적 I/O의 횟수가 늘어남
  - 물리적 I/O 횟수도 늘음

#### 정리
- 테이블 스캔이 항상 나쁜 것은 아님
- 인덱스 스캔이 항상 좋은 것은 아님
- 온라인 트랜잭션을 처리하는 프로그램과 DW/OLAP/배치 프로그램 튜닝의 특징을 구분 짓는 핵심 개념

### 온라인 프로그램 튜닝 VS 배치 프로그램 튜닝
1. 온라인 프로그램
   - 일반적으로 소량의 데이터를 읽고 갱신
   - 인덱스를 효과적으로 활용하는 것이 중요
   - 조인도 대부분 NL 방식을 사용
     - NL 조인은 인덱스를 이용하는 조인 방식
   - 인덱스를 이용해 소트 연산을 생략
   - 온라인 환경에서 대량 데이터를 조회할 때도 아주 빠른 응답 속도 가능
2. 배치 프로그램
  - 대량 데이터를 읽고 갱신하는 배치 프로그램
  - 항상 전체범위 처리 기준으로 튜닝해야 함
  - 처리대상이 집합 중 일부가 아니라 전체를 빠르게 처리하는 것을 목표로 삼아야 함
  - 대량 데이터를 빠르게 처리하려면, 인덱스와 NL 조인 < Full Scan과 해시 조인이 유리

- 아래는 실명확인번호로 조회한 특정 고객의 최근 1년 이내 변경 이력 중 월 말일 데이터를 출력하는 쿼리
```sql
select c.고객번호, c.고객명, h.전화번호, h.주소, h.상태코드, h.변경일시
from 고객 c, 고객변경이력 h
where c.실명확인번호 = :rmnno
and h.고객번호 = c.고객번호
and h.변경일시 = (select max(변경일시)
                from 고객변경이력 m
                where 고객번호 = c.고객번호
                and 변경일시 >= truc(add_months(sysdate, -12), 'mm')
                and 변경일시 < trunc(sysdate, 'mm'))
```
```sql
Execution Plan
--------------------------------------------------------------------------------------------
0         SELECT STATEMENT Optimizer=ALL_ROWS (Cost = ...)
1   0        NESTED LOOPS
2   1           NESTED LOOPS (Cost= ...)
3   2               NESTED LOOPS (Cost= ...)
4   3                  TABLE ACCESS (BY INDEX ROWID) OF '고객' (TABLE) (Cost= ...)
5   4                     INDEX (RANGE SCAN) OF '고객_X01' (INDEX (Cost= ...)
6   3                  VIEW PUSHED PREDICATE OF 'SYS.VW_SQ_1' (VIEW) (Cost= ...)
7   6                     SORT(AGGEGATE) (Cost= ...)
8   7                        FIRST ROW (Cost= ...)
9   8                           INDEX (RANGE SCAN (MIN/MAX)) OF '고객변경이력_PK' (Cost= ...)
10  2               INDEX (UNIQUE SCAN) OF '고객변경이력_PK' (INDEX (UNIQUE)) (Cost= ...)
11  1            TABLE ACCESS (BY INDEX ROWID) OF '고객변경이력' (TABLE) (Cost= ...)
```
- 실명확인번호 조건에 해당하는 데이터는 한 건이거나 소량
  - 인덱스와 NL 조인을 사용하는 위 방식이 효과적

- 예시2
  - 고객구분코드가 'A001'인 고객의 최근 1년 이내 변경 이력 중 전월 말일 데이터를 읽어 고객_임시 테이블에 입력
  - 전체 300만 명 중 고객구분코드 조건을 만족하는 고객은 100만 명
  - 아래와 같이 조건절만 바꿔서 직전과 같은 방식으로 수행하면 결코 빠른 성능을 낼 수 없음
```sql
insert into 고객_임시
select c.고객번호, c.고객명, h.전화번호, h.주소, h.상태코드, h.변경일시
from 고객 c, 고객변경이력 h
where c.고객구분코드 = 'A001'3갱
and h.고객번호 = c.고객번호
and h.변경일시 = (select max(변경일시)
              from 고객변경이력 m
              where 고객번호 = c.고객번호
                and 변경일시 >= truc(add_months(sysdate, -12), 'mm')
                and 변경일시 < trunc(sysdate, 'mm'))
```
- 쿼리를 아래와 같이 변경
- Full Scan과 해시 조인을 사용해야 효과적
- 조건절에 해당하지 않는 고객 데이터, 1년을 초과한 이력 데이터까지 읽는 비효율이 있지만, 수행속도는 훨씬 빠름
```sql
insert into 고객_임시
select /*+ full(c) full(h) index_ffs(m.고객변경이력)
            ordered no_merge(m) use_hash(m) use_hash(h) */
        c.고객번호, c.고객명, h.전화번호, h.주소, h.상태코드, h.변경일시
from 고객 c
    , (select 고객번호, max(변경일시) 최종변경일시
       from 고객변경이력
       where 변경일시 >= truc(add_months(sysdate, -12), 'mm')
         and 변경일시 < trunc(sysdate, 'mm')
      group by 고객번호) m,
     고객변경이력 h
where c.고객구분코드 = 'A001'
and m.고객번호 = c.고객번호
and h.고객번호 = m.고객번호
and h.변경일시 = m.최종변경일시;
```
- 고객변경이력 테이블을 두 번 읽는 비효율을 없애려면, 아래와 같이 윈도우 함수를 이용하면 된다.
```sql
insert into 고객_임시
select c.고객번호, c.고객명, h.전화번호, h.주소, h.상태코드, h.변경일시
from (select /*+ full(c) full(h) leading(c) use_hash(h) */
      c.고객번호, c.고객명, h.전화번호, h.주소, h.상태코드, h.변경일시,
      rank() over (partition by h.고객번호 order by h.변경일시 desc) no
      from 고객 c, 고객변경이력 h
      where c.고객구분코드 = 'A001'
          and h.변경일시 >= trunc(add_months(sysdate, -12), 'mm'
          and h.변경일시 < trunc(sysdate, 'mm')
          and h.고객번호 = c.고객번호)
where no = 1;
```
- 대량 배치 프로그램에서는 인덱스보다 Full Scan이 효과적
- 초대용량 테이블을 Full Scan하면 시스템에 주는 부담이 큼
- 배치 프로그램에서는 파티션 활용 전략이 매우 중요한 튜닝요소 + 병렬처리
- 위 쿼리에서는 고객변경이력 테이블을 변경일시 기준으로 파티셔닝하면, 변경일시 조건(최근 1년)에 해당하는 파티션만 골라서 Full Scan하므로 부담을 크게 줄일 수 있음
- 테이블을 파티셔닝하는 이유?
  - Full Scan을 빠르게 처리하기 위해서
- 모든 성능 문제를 인덱스로 해결하는 것 -> X
- 큰 테이블에서 아주 적은 일부 데이터를 빨리 찾고자 할 때 주로 사용

